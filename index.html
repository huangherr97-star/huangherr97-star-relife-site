export default async function handler(req, res) {
  // ---- CORS ----
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.setHeader("Access-Control-Max-Age", "86400");

  if (req.method === "OPTIONS") return res.status(200).end();

  // ---- GET: health check ----
  if (req.method === "GET") {
    return res.status(200).json({
      ok: true,
      msg: "RE:LIFE generate endpoint is alive",
      ts: new Date().toISOString(),
    });
  }

  // ---- Only POST below ----
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method Not Allowed", allow: ["GET", "POST", "OPTIONS"] });
  }

  try {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      return res.status(500).json({
        error: "Missing OPENAI_API_KEY in Vercel Environment Variables",
        detail: "请到 Vercel 项目 Settings -> Environment Variables 添加 OPENAI_API_KEY",
      });
    }

    // 兼容：body 可能是对象、也可能是字符串（某些场景）
    const body = typeof req.body === "string" ? safeParse(req.body) : (req.body || {});
    const normalized = normalizeBody(body);

    const missing = [];
    if (!normalized.background) missing.push("background");
    if (!normalized.timeline) missing.push("timeline");
    if (!normalized.target) missing.push("target");

    if (missing.length) {
      return res.status(400).json({
        error: "Missing required fields",
        need: missing,
        hint: "请确保提交 background/timeline/target（或 inputs.background/inputs.timeline/inputs.backTo）",
        gotKeys: Object.keys(body || {}),
      });
    }

    const model = process.env.OPENAI_MODEL || "gpt-4o-mini"; // 你也可以在 Vercel env 里改
    const temperature = clamp(Number(process.env.OPENAI_TEMPERATURE ?? 0.7), 0, 2);

    const system = buildSystemPrompt(normalized.mode);
    const user = buildUserPrompt(normalized);

    const out = await callOpenAIResponses({
      apiKey,
      model,
      temperature,
      system,
      user,
    });

    return res.status(200).json({
      ok: true,
      text: out,
    });
  } catch (err) {
    const msg = err?.message || String(err);
    return res.status(500).json({
      error: "Server error",
      message: msg,
    });
  }
}

// ---------------- helpers ----------------

function safeParse(s) {
  try { return JSON.parse(s); } catch { return {}; }
}

function clamp(n, a, b) {
  if (Number.isNaN(n)) return a;
  return Math.max(a, Math.min(b, n));
}

/**
 * 兼容输入：
 * A) { background, timeline, target, resources, mode, followup, history }
 * B) { inputs: { background, timeline, backTo, resources }, mode, followup, history }
 */
function normalizeBody(body) {
  const inputs = body?.inputs && typeof body.inputs === "object" ? body.inputs : null;

  const background = body.background ?? inputs?.background ?? "";
  const timeline   = body.timeline   ?? inputs?.timeline   ?? "";
  const target     = body.target     ?? inputs?.target     ?? inputs?.backTo ?? body.backTo ?? "";

  const resources  = body.resources  ?? inputs?.resources  ?? "";
  const mode       = body.mode       ?? "normal";
  const followup   = body.followup   ?? "";
  const history    = Array.isArray(body.history) ? body.history : [];

  return {
    background: String(background || "").trim(),
    timeline: String(timeline || "").trim(),
    target: String(target || "").trim(),
    resources: String(resources || "").trim(),
    mode: String(mode || "normal").trim(),
    followup: String(followup || "").trim(),
    history,
  };
}

function buildSystemPrompt(mode) {
  // mode: normal / dry / warm / plan
  const base = [
    "你是一个产品化的“人生推演助手”，名字叫 RE:LIFE（回环）。",
    "你只做基于用户输入的理性推演：给出可行路径、关键变量、风险点、可行动步骤。",
    "你必须明确：这不是算命，不保证结果，不替用户做决定。",
    "输出要中文，结构清晰，避免玄学词。",
  ].join("\n");

  const style = {
    normal: "语气：冷静中带点共情，短句为主，易读。",
    dry: "语气：更理性更简洁，少情绪，更多要点。",
    warm: "语气：更温和更共情，但仍以理性建议为主。",
    plan: "语气：更产品化。强制用 1/2/3/4/5 分段结构输出，步骤明确。",
  }[mode] || "语气：冷静中带点共情，短句为主，易读。";

  return `${base}\n${style}`;
}

function buildUserPrompt(d) {
  const parts = [
    `【个人背景】\n${d.background}`,
    `【人生经历时间线】\n${d.timeline}`,
    `【目标时间点（想回到）】\n${d.target}`,
  ];
  if (d.resources) parts.push(`【能力/资源（可选）】\n${d.resources}`);

  if (d.followup) {
    parts.push(`【追问】\n${d.followup}`);
  }

  // 历史（可选）
  if (d.history?.length) {
    const hist = d.history
      .slice(-6)
      .map((t, i) => `#${i + 1}(${t.type || "turn"} @ ${t.t || ""})\n${t.text || ""}`)
      .join("\n\n");
    parts.push(`【最近对话摘要（供参考）】\n${hist}`);
  }

  // 要求输出（兼容 plan 模式）
  const outputRule = [
    "请给出：",
    "1) 关键信息提炼（关键变量/约束）",
    "2) 3 条最可能路径（每条：短期/中期/长期）",
    "3) 每条路径的关键风险 & 规避策略",
    "4) 可执行清单（7天/30天）",
    "5) 需要补充的信息（最多5条问题）",
  ].join("\n");

  return parts.join("\n\n") + "\n\n" + outputRule;
}

// 使用 OpenAI Responses API（推荐）
async function callOpenAIResponses({ apiKey, model, temperature, system, user }) {
  const resp = await fetch("https://api.openai.com/v1/responses", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model,
      temperature,
      input: [
        { role: "system", content: [{ type: "text", text: system }] },
        { role: "user", content: [{ type: "text", text: user }] },
      ],
    }),
  });

  const text = await resp.text();
  let data = null;
  try { data = JSON.parse(text); } catch {}

  if (!resp.ok) {
    const msg = data?.error?.message || data?.message || text || `HTTP ${resp.status}`;
    throw new Error(msg);
  }

  // responses api：常见取法
  const out =
    data?.output_text ||
    extractFromOutput(data?.output) ||
    JSON.stringify(data, null, 2);

  return String(out).trim();
}

function extractFromOutput(output) {
  if (!Array.isArray(output)) return "";
  // 尝试把所有 text 拼起来
  const chunks = [];
  for (const item of output) {
    const content = item?.content;
    if (!Array.isArray(content)) continue;
    for (const c of content) {
      if (c?.type === "output_text" && c?.text) chunks.push(c.text);
      if (c?.type === "text" && c?.text) chunks.push(c.text);
    }
  }
  return chunks.join("\n").trim();
}
